### 1.闭包,两种情况：

#### 1.函数作为返回值被返回

#### 2.函数作为参数被传递

 解决方案 ：所有自由变量的值的查找都在函数定义的地方向上级查找

常见闭包的应用：闭包隐藏数据，只提供自定义的对外接口

```javascript
function createCache(){
    const data = {}
    return {
        set:function(key,val){
            data[key] = val
        },
        get:function(key){
            return data[key]
        }
    }
}
const c = createCache()
c.set(a,2)
c.get(a)
```



### 2.this指向的问题 ，在函数调用的时候才确认

```javascript
setTimeout(function(){

console.log(this) //指向window

},100)

setTimeout(() => {

console.log(this) //向箭头函数的上级作用域找

},100)
```

### 3.手写bind函数

```javascript
Founction.prototype.bind1 = function(){
    // 使用slice 把argument变为数组
    const arg = Array.prototype.slice.call(argument)
    // 把第一个参数,想指向的对象赋值给t,并且将其从参数数组中删除
    const t = arg.shift()
    // 拿到调用bind1的函数
    const self = this
    // 返回函数
    return self.call(t,arg)
}
```

### 4.ajax

### XMLHttpRequst

```javascript
// 手写简易的ajax
const xhr = new XMLHttpRequest()
// true 表示异步请求
xhr.open('GET','/api',true)
xhr.onreadystatechange = function(){
    if(xhr.readyState === 4) {
        if(xhr.status === 200) {
            alert(xhr.responseText)
        }
    }
}
// get请求发送null
xhr.send(null)
```

```javascript
// post 请求
const xhr = new XMLHttpRequest()
xhr.open('POST','/api',true)
xhr.onreadystatechange = function(){
if(xhr.readyState === 4) {
if(xhr.status===200) {
alert(xhr.responseText)
}
}
}
const postData = {
    a:'d'
    password:'ddddd'
}
//post请求的参数要发送，需要把json转化为字符串
xhr.send(JSON.stringify(postData))
```

```javascript
// promise封装一下
function ajax(ur){
    const p = new Promise((resolve,reject)=>{
        const xhr = new XMLHttpRequst()
        xhr.open('GET',url,true)
        xhr.onreadystatechange = function(){
            if(xhr.readyState === 4) {
                if(xhr.Status === 200) {
                    resolve(JSON.parse(xhr.responseText)
                }else if (xhr.Status === 404){
                    reject(new Error('404 NOT FOUND'))
                }
            }
        }
            xhr.send(null)
    })
    return p
}
// 使用
let url = 'xxxx/sxxxx/xxxxx.json'
ajax(url)
    .then(res=>{
       console.log(res) 
    })
    .catch(err=>{
        console.error(err)
    })
```



### 状态码 xhr.readyState

```
0 - 未初始化，还没有调用send()方法
1 - 已调用send()方法，正在发送请求
2 - send()方法执行完毕，已经接收到全部相应内容
3 - 正在解析返回的内容
4 - 解析完成返回内容可以在客户端调用
```

#### xhr.status

HTTP状态码

```
2xx - 成功处理请求，如200
3xx - 重定向，浏览器自己直接跳转
	301永久重定向
	302临时重定向
	304命中协商缓存
4xx - 客户端请求错误
	404 找不到请求资源
	403 客户端没有权限
5XX - 服务器端出错
```





### 跨域，同源策略，跨域解决方案

ajax请求时，浏览器要求当前网页和server必须同源

#### 同源：协议、域名、端口，三者必须一致（仅限浏览器）

####  跨域解决方案

- JSONP

  ```javascript
  // 原理<script>可以让过跨域，返回动态拼接的内容
  
  <script>
  	window.callback = function(data){
  		console.log(data)
  	}
  </script>
  <script src="https://xxx.com/getData.js"></script>
  ```

- CORS - 服务器设置http header

  ```
  response.setHeader('Access-Control-Allow-Origin','此处填跨域域的名称，不建议写*')
  response.setHeader('Access-Control-Allow-Headers','X-Requested-Witdh')
  response.setHeader('Access-Control-Allow-Methods','PUT,POST,GET,DELETE,OPTIONS')
  // 接受跨域的cookie
  response.setHeader('Access-Control-Allow-Credentials','true')
  ```

  

### 防抖 debounce

举例: 监听输入框的文字变化，用keyup时间会频繁触发，造成资源浪费，使用定时器来实现防抖

```javascript
const input1 = document.getElementById('input1')
let timer = null
input1.addEventListener('keyup',funciton()){
    // 先清空定时器
    if(timer) {
        clearTimeout(timer)
    }
    timer = setTimeout(()=>{
        console.log(input1.value)
        // 定时器清空
        timer = null
    },500)
}
```

```javascript
// 封装一下debounce
function debounce(fn,delay=500){
    // timer 是被闭包隐藏起来的 
    let timer = null
    return function(){
        if (timer){
            clearTimeout(time)
        }
        timer = setTimeout(()=>{
            fn.apply(this,argunment)
            // 或者直接写成fn()
            timer = null
        },delay)
    }
    
}

// 使用
input1.addEventListener('keyup',debounce(function(){}),500)

```

### 节流

举例:拖拽时随时获得该元素被拖拽的位置，直接用drag时间，会频繁触发，造成性能浪费

```javascript
const box = document.getElementById('box')
box.addEventListener('drag',function(){
    if(timer){
        // 有定时任务直接return
        return
    }
    timer = setTimeout(()=>{
        console.log('！！！')
        // 触发后清除定时器
        timer = null
    },100)
})
```

```javascript
// 封装节流
function throttle(fn,delay=100){
	let timer = null
	return function(){
        if (timer){
            return
        }
        timer = setTimeout(()=>{
            // 可以直接写成fn()
            fn.apply(this,arguments)
            timer = null 
        },delay)
    }
	
}
// 用法
box.addEventListener('drag',throttle(function(){},200))
```













